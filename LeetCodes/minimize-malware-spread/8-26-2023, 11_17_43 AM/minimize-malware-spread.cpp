// Link: https://leetcode.com/problems/minimize-malware-spread

/** Submission Info:
 *
 *  AUTHOR: the_247 | Raj Patel
 *  TITLE: minimize-malware-spread
 *  RUNTIME: 143 ms
 *  MEMORY: 65.1 MB
 *  DATE: 8-26-2023, 11:17:43 AM
 *
 */

// Solution:

class DisjointSet {
public:
    vector<int> par, size;
    DisjointSet(int n) {
        size.resize(n, 1);
        par.resize(n);
        for(int i=0; i<n; i++) 
            par[i] = i;
    }

    int findPar(int x) {
        if(par[x] == x) return x;
        return par[x] = findPar(par[x]);
    }

    bool merge(int x, int y) {
        int px = findPar(x);
        int py = findPar(y);

        if(px == py) return true;

        if(size[px] < size[py]) {
            par[py] = px;
            size[px] += size[py];
        } else {
            par[px] = py;
            size[py] += size[px];
        }
        return false;
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        sort(initial.begin(), initial.end());
        int n = graph.size();
        DisjointSet ds(n);

        for(int i=0; i<n; i++) 
            for(int j=0; j<n; j++) 
                if(graph[i][j])
                    ds.merge(i, j);
        
        vector<int> cnt(n, 0);
        for(auto &node: initial) {
            int parNode = ds.findPar(node);
            cnt[parNode]++;
        }

        int ans = initial[0], mini = 0;
        for(auto &x: initial) {
            int parNode = ds.findPar(x);
            int parSize = ds.size[parNode];
            if(cnt[parNode] == 1 && mini < parSize) {
                mini = parSize;
                ans = x;
            }
        }
        return ans;
    }
};
